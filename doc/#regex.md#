# 1.’¡¡’Àµ’µ¬’É½’¸½
’Àµ’µ¬’É½’¸½’¡Êregular expression’¡¢regex’¡Ë’¤È’¤Ï’¡¢’Ê¸’»ú’Îó’¤Î’½¸’¹ç’¤ò’Ê¸’»ú’Îó’¤Ç’É½’¸½’¤¹’¤ë’Êý’Ë¡’¤Î’¤³’¤È’¤Ç’¡¢’Ê¸’»ú’Îó’¤Î’¥Ñ’¥¿’¡¼’¥ó’¥Þ’¥Ã’¥Á’¤ò’¹Ô’¤¦’¤¿’¤á’¤Ë’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
’Àµ’µ¬’É½’¸½’¤Ï<a href="https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A7%E3%83%A0%E3%82%B9%E3%82%AD%E3%83%BC%E9%9A%8E%E5%B1%A4" target="_blank">’¥Á’¥ç’¥à’¥¹’¥­’¡¼’³¬’ÁØ</a>’¤Î’£³’·¿’Ê¸’Ë¡’¡Ê’¹½’Ê¸’ÌÚ’¤Ï’º¬’¤¬’£±’¤Ä’¤Î’Æó’Ê¬’ÌÚ’¡¢’Æþ’¤ì’»Ò’¹½’Â¤’¤ò’»ý’¤¿’¤Ê’¤¤’Ê¸’Ë¡’¡¢’Àµ’µ¬’Ê¸’Ë¡’¤«’¤é’À¸’À®’²Ä’Ç½’¡¢’Í­’¸Â’¥ª’¡¼’¥È’¥Þ’¥È’¥ó’¤Ë’¤è’¤Ã’¤Æ’¼õ’Íý’²Ä’Ç½’¡Ë’¤Ç’¤¹’¡£’°ì’ÈÌ’Åª’¤Ë’¥×’¥í’¥°’¥é’¥ß’¥ó’¥°’¤Ë’¤ª’¤±’¤ë’Àµ’µ¬’É½’¸½’¤Ï’¡¢’¤É’¤ó’¤Ê’Ê¸’»ú’¤Ë’¤â’°ì’Ã×’¤¹’¤ë’ÆÃ’¼ì’Ê¸’»ú’¡Ö’¥ï’¥¤’¥ë’¥É’¥«’¡¼’¥É’¡×’¤ò’²Ã’¤¨’¤Æ’ÁÈ’¤ß’¹ç’¤ï’¤»’¤¿’¤â’¤Î’¤ò’»Ø’¤·’¤Þ’¤¹’¡£’¸·’Ì©’¤Ë’¤Ï’¡¢’Àµ’µ¬’É½’¸½’¤È’¥ï’¥¤’¥ë’¥É’¥«’¡¼’¥É’¤Ï’¥×’¥í’¥°’¥é’¥ß’¥ó’¥°’¸À’¸ì’Àß’·×’¾å’ÊÌ’¤Î’µ¡’¹½’¤Ç’¤¹’¤¬’¡¢’¥Ñ’¥¿’¡¼’¥ó’¥Þ’¥Ã’¥Á’¤ò’¹Ô’¤¦’¾å’¤Ç’Î¾’Êý’¤ò’¥·’¡¼’¥à’¥ì’¥¹’¤Ë’»È’¤¨’¤ë’¤Î’¤Ç’¡¢’¤³’¤³’¤Ç’¤Î’Àµ’µ¬’É½’¸½’¤Ï’ÊØ’µ¹’¾å’¥ï’¥¤’¥ë’¥É’¥«’¡¼’¥É’¤È’ÁÈ’¤ß’¹ç’¤ï’¤»’¤¿’¤â’¤Î’¤ò’»Ø’¤¹’¤³’¤È’¤Ë’¤·’¤Þ’¤¹’¡£<br>
<br>
’Àµ’µ¬’É½’¸½’¤Î’Îã’¤È’¤·’¤ÆUCS-2’¡Ê2-byte Universal Character Set’¡Ë’¡¢UTF-16’¡Ê’¥Ó’¥Ã’¥°’¥¨’¥ó’¥Ç’¥£’¥¢’¥ó’¡Ë’¡¢UTF-16’¡Ê’¥ê’¥È’¥ë’¥¨’¥ó’¥Ç’¥£’¥¢’¥ó’¡Ë’¤Î’Àµ’µ¬’É½’¸½’¤ò’¼¡’¤Ë’¼¨’¤·’¤Þ’¤¹’¡£<br><br>
’Îã’¡§UCS-2’¤ò’É½’¤¹’Àµ’µ¬’É½’¸½<strong>’¡ÊScala’¤ÎChar / Java’¤Îchar’¤Ë’Áê’Åö’¡Ë</strong>
```
[\\x00-\\xFF][\\x00-\\xFF]
```

’Îã’¡§UTF-16’¡Ê’¥Ó’¥Ã’¥°’¥¨’¥ó’¥Ç’¥£’¥¢’¥ó’¡Ë’¤ò’É½’¤¹’Àµ’µ¬’É½’¸½

BOM’¡§
```
\\xFE\\xFF
```

’Ê¸’»ú’¡§<strong>’¡ÊScala/Java’¤Î’Ê¸’»ú’¡Ë</strong>

```
([\\x00-\\xD7\\xE0-\\xFF][\\x00-\\xFF]|[\\xD8-\\xDB][\\x00-\\xFF][\\xDC-\\xDF][\\x00-\\xFF])
```
UTF-16’¡Ê’¥Ó’¥Ã’¥°’¥¨’¥ó’¥Ç’¥£’¥¢’¥ó’¡Ë’¤Î’Ê¸’»ú’¤Î’¹½’Â¤’¤¬’¤ï’¤«’¤ê’¤ä’¤¹’¤¤’¤è’¤¦’¤Ë’Àµ’µ¬’É½’¸½’¤Ë’²þ’¹Ô’¤È’¥¤’¥ó’¥Ç’¥ó’¥È’¤È’¥³’¥á’¥ó’¥È’¤ò’²Ã’¤¨’¤¿’¿Þ’¡§
```
(
               [\\x00-\\xD7\\xE0-\\xFF][\\x00-\\xFF]|//UCS-2
[\\xD8-\\xDB][\\x00-\\xFF][\\xDC-\\xDF][\\x00-\\xFF] //UTF-16’Âå’Íý’ÎÎ’°è’¡Ê’¥µ’¥í’¥²’¡¼’¥È’¥Ú’¥¢’¡Ë
//’¡Ê’º¸’¤Î2’¥ª’¥¯’¥Æ’¥Ã’¥È’¤¬high surrogate’¡¢’±¦’¤Î2’¥ª’¥¯’¥Æ’¥Ã’¥È’¤¬low surrogate’¡Ë
)
```

’Îã’¡§UTF-16’¡Ê’¥ê’¥È’¥ë’¥¨’¥ó’¥Ç’¥£’¥¢’¥ó’¡Ë’¤ò’É½’¤¹’Àµ’µ¬’É½’¸½

BOM’¡§
```
\\xFF\\xFE
```

’Ê¸’»ú’¡§
```
([\\x00-\\xFF][\\x00-\\xD7\\xE0-\\xFF]|[\\x00-\\xFF][\\xD8-\\xDB][\\x00-\\xFF][\\xDC-\\xDF])
```
UTF-16’¡Ê’¥ê’¥È’¥ë’¥¨’¥ó’¥Ç’¥£’¥¢’¥ó’¡Ë’¤Î’Ê¸’»ú’¤Î’¹½’Â¤’¤¬’¤ï’¤«’¤ê’¤ä’¤¹’¤¤’¤è’¤¦’¤Ë’Àµ’µ¬’É½’¸½’¤Ë’²þ’¹Ô’¤È’¥¤’¥ó’¥Ç’¥ó’¥È’¤È’¥³’¥á’¥ó’¥È’¤ò’²Ã’¤¨’¤¿’¿Þ’¡§
```
(
               [\\x00-\\xFF][\\x00-\\xD7\\xE0-\\xFF]|//UCS-2
[\\x00-\\xFF][\\xD8-\\xDB][\\x00-\\xFF][\\xDC-\\xDF] //UTF-16’Âå’Íý’ÎÎ’°è’¡Ê’¥µ’¥í’¥²’¡¼’¥È’¥Ú’¥¢’¡Ë
//’¡Ê’±¦’¤Î2’¥ª’¥¯’¥Æ’¥Ã’¥È’¤¬low surrogate’¡¢’º¸’¤Î2’¥ª’¥¯’¥Æ’¥Ã’¥È’¤¬high surrogate’¡Ë
)
```
Scala / Java’¤Ë’¤ª’¤±’¤ë’Àµ’µ¬’É½’¸½’¤Î’Äê’µÁ’¤Ï<a href="http://docs.oracle.com/javase/jp/8/docs/api/java/util/regex/Pattern.html" target="_blank">Java’¤ÎJavadoc’¤ÎPattern’¥¯’¥é’¥¹</a>’¤Ë’½ñ’¤«’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£
’¾Ü’ºÙ’¤Ê’Äê’µÁ’¤ÏPattern’¥¯’¥é’¥¹’¤Î’Àâ’ÌÀ’¤ò’ÆÉ’¤ó’¤Ç’¤¯’¤À’¤µ’¤¤’¡£
’¤³’¤³’¤Ç’¤Ï’¡¢’½è’Íý’¤Î’ÌÜ’Åª’¤ò’¡¢’°ì’Ã×’¡¢’Ê¬’³ä’¡¢’Ãê’½Ð’¡¢’ÃÖ’´¹’¤Ë’Ê¬’¤±’¤Æ’¤½’¤ì’¤¾’¤ì’¤Î’½è’Íý’¤Ç’Àµ’µ¬’É½’¸½’¤ò’»È’¤¤’Êý’¤ò’Àâ’ÌÀ’¤·’¤Þ’¤¹’¡£

’Àµ’µ¬’É½’¸½’¤Ï’¡¢String’¥¯’¥é’¥¹’¡¢Pattern’¥¯’¥é’¥¹’¡¢Regex’¥¯’¥é’¥¹’¤Î’¥á’¥½’¥Ã’¥É’¤Ç’»È’ÍÑ’¤Ç’¤­’¤Þ’¤¹’¡£
String’¥¯’¥é’¥¹’¤Ç’Àµ’µ¬’É½’¸½’¤ò’°ú’¿ô’¤È’¤¹’¤ë’¥á’¥½’¥Ã’¥É’¤Ï’¤«’¤Ê’¤ê’¥æ’¡¼’¥Æ’¥£’¥ê’¥Æ’¥£’¤¬’Èó’¾ï’¤Ë’¹â’¤¯’Å¬’±þ’ÈÏ’°Ï’¤¬’¤«’¤Ê’¤ê’¸Â’Äê’Åª’¤Ê’¤â’¤Î’¡Êmatches’¡¢split’¡Ë’¤Ç’¤¹’¡£
’Àµ’µ¬’É½’¸½’¤Ç’²Ä’Ç½’¤Ê’Á´’¤Æ’¤Î’½è’Íý’¤ò’¹Ô’¤¦’¤Ë’¤ÏPattern’¥¯’¥é’¥¹’¤«Regex’¥¯’¥é’¥¹’¤ò’»È’ÍÑ’¤¹’¤ë’É¬’Í×’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£
Pattern’¥¯’¥é’¥¹’¤ÏJava’¤ÎAPI’¤Ç’¡¢Regex’¥¯’¥é’¥¹’¤ÏScala’¤ÎAPI’¤Ç’¤¹’¡£
Regex’¥¯’¥é’¥¹’¤ò’»È’ÍÑ’¤¹’¤ë’¤Èmatch-case’Ê¸’¤Ç’¥Ñ’¥¿’¡¼’¥ó’¥Þ’¥Ã’¥Á’¤Î’Ê¬’´ô’¤ò’½ñ’¤¤’¤¿’¤ê’¡¢’Ãê’½Ð’¤·’¤¿’¥°’¥ë’¡¼’¥×’¤Î’ÊÑ’¿ô’Ì¾’¤ò’»Ø’Äê’¤¹’¤ë’¤³’¤È’¤¬’¤Ç’¤­’¡¢Pattern’¥¯’¥é’¥¹’¤è’¤ê’¤â’Ä¾’´¶’Åª’¤Ë’¼Â’Áõ’¤Ç’¤­’¤Þ’¤¹’¡£

’¤Ê’¤ª’¡¢’¿Í’´Ö’¤¬’»È’ÍÑ’¤¹’¤ë’¼«’Á³’¸À’¸ì’¤Ï’¥Á’¥ç’¥à’¥¹’¥­’¡¼’³¬’ÁØ’¤Ç’¤Î’²¿’·¿’Ê¸’Ë¡’¤Ê’¤Î’¤«’¶½’Ì£’¤¬’¤¢’¤ë’¿Í’¤Ï<a href="#’¥³’¥é’¥à’¼«’Á³’¸À’¸ì’¤Ï’¥Á’¥ç’¥à’¥¹’¥­’¡¼’³¬’ÁØ’¤Ç’¤Î’²¿’·¿’Ê¸’Ë¡">’¥³’¥é’¥à’¡§’¼«’Á³’¸À’¸ì’¤Ï’¥Á’¥ç’¥à’¥¹’¥­’¡¼’³¬’ÁØ’¤Ç’¤Î’²¿’·¿’Ê¸’Ë¡’¡©</a>’¤ò’»²’¾È’¤·’¤Æ’¤¯’¤À’¤µ’¤¤’¡£
<br>

***
<h3>1.1’¡¡’°ì’Ã×</h3>
<ul>
  <li>’´°’Á´’°ì’Ã×’¡Êexact match’¡Ë’¡§ABCD’¤ÏABCD’¤Ë’´°’Á´’°ì’Ã×</li>
  <li>’Éô’Ê¬’°ì’Ã×’¡Êbroad match / partial match’¡Ë’¡§BC’¤ÏABCD’¤Ë’Éô’Ê¬’°ì’Ã×’¡¢’²¼’µ­’¤Î’Á°’Êý’°ì’Ã×’¡¦’¸å’Êý’°ì’Ã×’¤Ï’Éô’Ê¬’°ì’Ã×’¤Î’ÆÃ’¼ì’Îã’¡¢’°ì’ÈÌ’Åª’¤Ë’´°’Á´’°ì’Ã×’¤Ï’Éô’Ê¬’°ì’Ã×’¤Ë’´Þ’¤á’¤Þ’¤»’¤ó’¤¬’ÆÃ’¼ì’Îã’¤È’¤·’¤Æ’²ò’¼á’¤¹’¤ë’¤³’¤È’¤â’²Ä’Ç½’¤Ç’¤¹’¡£
’¡¡  <ul>
’¡¡    <li>’Á°’Êý’°ì’Ã×’¡Êforward match’¡Ë’¡§AB’¤ÏABCD’¤Ë’Á°’Êý’°ì’Ã×</li>
’¡¡    <li>’¸å’Êý’°ì’Ã×’¡Êbackward match’¡Ë’¡§CD’¤ÏABCD’¤Ë’¸å’Êý’°ì’Ã×</li>
’¡¡  </ul>
’¡¡</li>
</ul>
<table>
<tr>
<th>’°ì’Ã×’¤Î’¼ï’Îà</th>
<th>’É½’ÁØ’Ê¸’»ú’Îó’°ì’Ã×’¤Î’¥á’¥½’¥Ã’¥É’Ì¾</th>
<th>’Àµ’µ¬’É½’¸½’¤Ë’¤è’¤ë’¥Ñ’¥¿’¡¼’¥ó’¥Þ’¥Ã’¥Á’¤Î’¥á’¥½’¥Ã’¥É’Ì¾</th>
</tr>
<tr>
<td>’´°’Á´’°ì’Ã×</td>
<td>equals, ==</td>
<td>matches</td>
</tr>
<tr>
<td>’Éô’Ê¬’°ì’Ã×</td>
<td>contains</td>
<td>find</td>
</tr>
<tr>
<td>’Á°’Êý’°ì’Ã×</td>
<td>startsWith</td>
<td>lookingAt</td>
</tr>
<tr>
<td>’¸å’Êý’°ì’Ã×</td>
<td>endsWith</td>
<td>&nbsp;</td>
</tr>
</table>
<table>
<tr>
<th>’°ì’Ã×’¤Î’¼ï’Îà</th>
<th>’¼¡’¤Î’Àµ’µ¬’É½’¸½’¤ò’»È’¤¦’¤È’´°’Á´’°ì’Ã×’¤Îmatches’¥á’¥½’¥Ã’¥É’¤Ê’¤É’¤Ç’¼Â’Áõ’²Ä’Ç½</th>
</tr>
<tr>
<td>’´°’Á´’°ì’Ã×</td>
<td>[’Àµ’µ¬’É½’¸½]</td>
</tr>
<tr>
<td>’Éô’Ê¬’°ì’Ã×</td>
<td>.*[’Àµ’µ¬’É½’¸½].*</td>
</tr>
<tr>
<td>’Á°’Êý’°ì’Ã×</td>
<td>[’Àµ’µ¬’É½’¸½].*</td>
</tr>
<tr>
<td>’¸å’Êý’°ì’Ã×</td>
<td>.*[’Àµ’µ¬’É½’¸½]</td>
</tr>
</table>
<table>
<tr>
<th>’°ì’Ã×’¤Î’¼ï’Îà</th>
<th>’¼¡’¤Î’Àµ’µ¬’É½’¸½’¤ò’»È’¤¦’¤È’Éô’Ê¬’°ì’Ã×’¤Îfind’¥á’¥½’¥Ã’¥É’¤Ê’¤É’¤Ç’¼Â’Áõ’²Ä’Ç½</th>
</tr>
<tr>
<td>’´°’Á´’°ì’Ã×</td>
<td>^[’Àµ’µ¬’É½’¸½]$</td>
</tr>
<tr>
<td>’Éô’Ê¬’°ì’Ã×</td>
<td>[’Àµ’µ¬’É½’¸½]</td>
</tr>
<tr>
<td>’Á°’Êý’°ì’Ã×</td>
<td>^[’Àµ’µ¬’É½’¸½]</td>
</tr>
<tr>
<td>’¸å’Êý’°ì’Ã×</td>
<td>[’Àµ’µ¬’É½’¸½]$</td>
</tr>
</table>
<table>
<tr>
<th>’°ì’Ã×’¤Î’¼ï’Îà</th>
<th>’¼¡’¤Î’Àµ’µ¬’É½’¸½’¤ò’»È’¤¦’¤È’Á°’Êý’°ì’Ã×’¤ÎlookingAt’¥á’¥½’¥Ã’¥É’¤Ç’¼Â’Áõ’²Ä’Ç½</th>
</tr>
<tr>
<td>’´°’Á´’°ì’Ã×</td>
<td>[’Àµ’µ¬’É½’¸½]$</td>
</tr>
<tr>
<td>’Éô’Ê¬’°ì’Ã×</td>
<td>.*[’Àµ’µ¬’É½’¸½]</td>
</tr>
<tr>
<td>’Á°’Êý’°ì’Ã×</td>
<td>[’Àµ’µ¬’É½’¸½]</td>
</tr>
<tr>
<td>’¸å’Êý’°ì’Ã×</td>
<td>&nbsp;</td>
</tr>
</table>
<ul>
<li>’ºÇ’Ä¹’°ì’Ã×</li>
<li>’ºÇ’Ã»’°ì’Ã×</li>
</ul>
***
<h4>1.1.1’¡¡’´°’Á´’°ì’Ã×’¡Ê’É½’ÁØ’Ê¸’»ú’Îó’¡Ë</h4>
’É½’ÁØ’Ê¸’»ú’Îó’¤Î’´°’Á´’°ì’Ã×’¤Ï==’±é’»»’»Ò’¤«Java’Í³’Íè’¤Îequals’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
Java’¤Ç’¤Ï’¡¢==’±é’»»’»Ò’¤ò’»È’ÍÑ’¤¹’¤ë’¤È’»²’¾È’¤Î’°ì’Ã×’¤ò’¸«’¤Æ’¤·’¤Þ’¤¤’¡¢’Ê¸’»ú’Îó’¤È’¤·’¤Æ’¤Ï’Åù’ÃÍ’¤Ç’¤¢’¤Ã’¤Æ’¤âfalse’¤ò’ÊÖ’¤·’¤Æ’¤·’¤Þ’¤¦’²Ä’Ç½’À­’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£’¤½’¤Î’¤¿’¤á’¡¢’Ê¸’»ú’Îó’¤È’¤·’¤Æ’¤Î’Åù’ÃÍ’¤ò’Àµ’¤·’¤¯’ÊÖ’¤¹’¤¿’¤á’¤Ëequals’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤·’¤¿’¡£
letter case’¤ò’Ìµ’»ë’¤·’¤Æ’¡Ê’Îã’¤¨’¤Ð’¡¢’Á´’¤Ælower case’¤Ë’Â·’¤¨’¤Æ’¡Ë’¤«’¤é’´°’Á´’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤ÏequalsIgnoreCase’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
==’±é’»»’»Ò’¤äequals’¥á’¥½’¥Ã’¥É’¤Î’Âå’ÂØ’¤Ëcompare’¥á’¥½’¥Ã’¥É’¡¢compareTo’¥á’¥½’¥Ã’¥É’¤ä’¡¢equalsIgnoreCase’¥á’¥½’¥Ã’¥É’¤Î’Âå’¤ï’¤ê’¤ËcompareToIgnoreCase’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’¤³’¤È’¤¬’¤Ç’¤­’¤Þ’¤¹’¤¬’¡¢==’±é’»»’»Ò’¤äequals’¥á’¥½’¥Ã’¥É’¤Ïnull’¤ò’Èæ’³Ó’¤¹’¤ë’¾ì’¹ç’¤Ç’¤âBoolean’¤ò’ÊÖ’¤·’¤Þ’¤¹’¤¬’¡¢compare’·Ï’¥á’¥½’¥Ã’¥É’¤Ïnull’¤Ë’ÂÐ’¤·’¤Æjava.lang.NullPointerException’¤ò’ÊÖ’¤¹’ÅÀ’¤¬’°ã’¤¤’¤Þ’¤¹’¡£
Scala’¤Ç’¤Ï’¡¢==’±é’»»’»Ò’¤ò’»È’ÍÑ’¤¹’¤ë’¤È’Ê¸’»ú’Îó’¤È’¤·’¤Æ’¤Î’Åù’ÃÍ’¤ò’¸«’¤ë’¤³’¤È’¤¬’¤Ç’¤­’¤Þ’¤¹’¤¬’¡¢Java’¤Î==’±é’»»’»Ò’¤Î’¤è’¤¦’¤Ë’»²’¾È’¤Î’°ì’Ã×’¤ò’ÃÎ’¤ê’¤¿’¤¤’¾ì’¹ç’¤Ï’¡¢’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤Ïeq’±é’»»’»Ò’¡¢’ÉÔ’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤Ïne’±é’»»’»Ò’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
```scala
  private val unagiCopula: String = "’ËÍ’¤Ï’¥¦’¥Ê’¥®"
  
  @Test
  def testStringEqualExpression(): Unit = {
    assert(unagiCopula == "’ËÍ’¤Ï’¥¦’¥Ê’¥®")
    assert(unagiCopula.equals("’ËÍ’¤Ï’¥¦’¥Ê’¥®"))
    assert(unagiCopula.compare("’ËÍ’¤Ï’¥¦’¥Ê’¥®") == 0)
    assert(unagiCopula.compareTo("’ËÍ’¤Ï’¥¦’¥Ê’¥®") == 0)

    assert(unagiCopula != "’ËÍ’¤Ï’¥¦’¥µ’¥®")
    assert(!unagiCopula.equals("’ËÍ’¤Ï’¥¦’¥µ’¥®"))
    assert(unagiCopula.compare("’ËÍ’¤Ï’¥¦’¥µ’¥®") != 0)
    assert(unagiCopula.compareTo("’ËÍ’¤Ï’¥¦’¥µ’¥®") != 0)

    assert(unagiCopula != null)
    assert(!unagiCopula.equals(null))
    //java.lang.NullPointerException
    //assert(unagiCopula.compare(null) != 0)
    //java.lang.NullPointerException
    //assert(unagiCopula.compareTo(null) != 0)
  }

  @Test
  def testStringEqualExpressionIngnoreCase(): Unit = {
    assert(!"I am Unagi.".equals("i am unagi."))
    assert("I am Unagi.".equalsIgnoreCase("i am unagi."))
    assert("I am Unagi.".compareToIgnoreCase("i am unagi.") == 0)

    assert(!"I am Unagi.".equalsIgnoreCase(null))
    //java.lang.NullPointerException
    //assert("I am Unagi.".compareToIgnoreCase(null) != 0)
  }

  @Test
  def testStringEqualExpression2(): Unit = {
    assert(unagiCopula eq "’ËÍ’¤Ï’¥¦’¥Ê’¥®")
    assert(unagiCopula ne "’ËÍ’¤Ï’¥¦’¥µ’¥®")
  }
```
***
<h4>1.1.2’¡¡’´°’Á´’°ì’Ã×’¡Ê’Àµ’µ¬’É½’¸½’¡Ë</h4>
’¥Ñ’¥¿’¡¼’¥ó’¥Þ’¥Ã’¥Á’¤Î’´°’Á´’°ì’Ã×’¤ò’Àµ’µ¬’É½’¸½’¤ò’ÍÑ’¤¤’¤Æ’¸«’¤ë’¾ì’¹ç’¤Ï’¡¢String’¥¯’¥é’¥¹’¤Îmatches’¥á’¥½’¥Ã’¥É’¡¢Pattern’¥¯’¥é’¥¹’¤Îmatches’¥á’¥½’¥Ã’¥É’¡¢Matcher’¥¯’¥é’¥¹’¤Îmatches’¥á’¥½’¥Ã’¥É’¡¢Regex’¥¯’¥é’¥¹’¤ò’ÍÑ’¤¤’¤ë’Êý’Ë¡’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£String’¥¯’¥é’¥¹’¤Îmatches’¥á’¥½’¥Ã’¥É’¤Ï’½è’Íý’Â®’ÅÙ’¤¬’ÃÙ’¤¤’¤Ç’¤¹’¡£Pattern’¥¯’¥é’¥¹’¤Îmatches’¥á’¥½’¥Ã’¥É’¤ÈRegex’¥¯’¥é’¥¹’¤Ç’¤ÏPattern’¥¯’¥é’¥¹’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’¤¬’½è’Íý’Â®’ÅÙ’¤¬’Â®’¤¤’¤Ç’¤¹’¡£’²¿’ÅÙ’¤â’Æ±’¤¸’¥Ñ’¥¿’¡¼’¥ó’¤Ç’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤Ï’¡¢Pattern’¥¯’¥é’¥¹’¤Ï’°ì’ÅÙcompile’¥á’¥½’¥Ã’¥É’¤Ç’¥³’¥ó’¥Ñ’¥¤’¥ë’¤·’¤ÆPattern’¤Î’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤·’¤Æ’¤ª’¤¤’¤Æ’¡¢’¤½’¤ì’¤ò’²¿’ÅÙ’¤â’»È’ÍÑ’¤¹’¤ë’Êý’¤¬’¹â’Â®’¤Ç’¤¹’¤·’¡¢Regex’¥¯’¥é’¥¹’¤Ë’¤Ä’¤¤’¤Æ’¤â’¡¢’°ì’ÅÙString’¥¯’¥é’¥¹’¤Îr’¥á’¥½’¥Ã’¥É’¤ÇRegex’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤·’¤Æ’¤ª’¤¤’¤Æ’¡¢’¤½’¤ì’¤ò’²¿’ÅÙ’¤â’»È’ÍÑ’¤¹’¤ë’Êý’¤¬’¹â’Â®’¤Ç’¤¹’¡£’¤³’¤Î’¾ì’¹ç’¤Ç’¤âPattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’¤¬Regex’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’»È’ÍÑ’¤¹’¤ë’¤è’¤ê’¹â’Â®’¤Ç’¤¹’¡£’¥³’¥ó’¥Ñ’¥¤’¥ë’¤µ’¤ì’¤¿Pattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤Ïmatcher’¥á’¥½’¥Ã’¥É’¤Ç’ÂÐ’¾Ý’¤Î’Ê¸’»ú’Îó’¤ò’Í¿’¤¨’¡¢Matcher’¥¯’¥é’¥¹’¤Î’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤·’¡¢Matcher’¥¯’¥é’¥¹’¤Îmatches’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’¤³’¤È’¤Ç’´°’Á´’°ì’Ã×’¤·’¤¿’¤«’¤ò’³Î’Ç§’¤Ç’¤­’¤Þ’¤¹’¡£
```scala
  private val unagiCopula: String = "’ËÍ’¤Ï’¥¦’¥Ê’¥®"
  
  @Test
  def testExactMatch1(): Unit = {
    assert(unagiCopula.matches("’ËÍ’¤Ï’¥¦’¥Ê’¥®"))
  }

  @Test
  def testExactMatch2(): Unit = {
    assert(Pattern.matches("’ËÍ’¤Ï’¥¦’¥Ê’¥®", unagiCopula))
  }

  @Test
  def testExactMatch3(): Unit = {
    val pattern: Pattern = Pattern.compile("’ËÍ’¤Ï’¥¦’¥Ê’¥®")
    val matcher: Matcher = pattern.matcher(unagiCopula)

    assert(matcher.matches)
  }

  @Test
  def testExactMatch4(): Unit = {
    val regex: Regex = """’ËÍ’¤Ï’¥¦’¥Ê’¥®""".r
    unagiCopula match {
      case regex() =>
        assert(true)
      case otherwise =>
        assert(false)
    }
  }
```
***
<h4>1.1.3’¡¡’Éô’Ê¬’°ì’Ã×’¡Ê’É½’ÁØ’Ê¸’»ú’Îó’¡Ë</h4>
’É½’ÁØ’Ê¸’»ú’Îó’¤Î’Éô’Ê¬’°ì’Ã×’¤ò’¸«’¤ë’¤¿’¤á’¤Ë’¤Ï’¡¢Java’Í³’Íè’¤Îcontains’¥á’¥½’¥Ã’¥É’¤ÈScala’Í³’Íè’¤ÎcontainsSlice’¥á’¥½’¥Ã’¥É’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£
contains’¥á’¥½’¥Ã’¥É’¤Ï’Æ±’¤¸’¤¯String’¥¯’¥é’¥¹’¤ÎindexOf’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Æ’¼Â’Áõ’¤µ’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£indexOf’¥á’¥½’¥Ã’¥É’¤Ï’Àè’Æ¬’¤«’¤é’½ç’ÈÖ’¤Ë’°ì’¤Ä’¤º’¤Ä’¸«’¤Æ’¤¤’¤­’°ì’Ã×’¤·’¤¿’¤é’¤½’¤Î’°Ì’ÃÖ’¥¤’¥ó’¥Ç’¥Ã’¥¯’¥¹’¤ò’ÊÖ’¤¹’¥á’¥½’¥Ã’¥É’¤Ç’¤¹’¡£’¤â’¤·’¸«’¤Ä’¤«’¤é’¤Ê’¤«’¤Ã’¤¿’¾ì’¹ç’¤ÏindexOf’¥á’¥½’¥Ã’¥É’¤«’¤é-1’¤¬’ÊÖ’¤Ã’¤Æ’¤­’¤Þ’¤¹’¤Î’¤Ç’¡¢’ÊÖ’¤ê’ÃÍ’¤¬-1’¤Ç’¤Ï’¤Ê’¤±’¤ì’¤Ðcontains’¥á’¥½’¥Ã’¥É’¤Ïtrue’¤ò’ÊÖ’¤·’¡¢-1’¤Î’¾ì’¹ç’¤Ïfalse’¤ò’ÊÖ’¤·’¤Þ’¤¹’¡£
containsSlice’¥á’¥½’¥Ã’¥É’¤ÏSeqLike’¥¯’¥é’¥¹’¤ÎindexOfSlice’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Æ’¡¢contains’¥á’¥½’¥Ã’¥É’¤È’Æ±’ÍÍ’¤ËindexOfSlice’¥á’¥½’¥Ã’¥É’¤Î’ÊÖ’¤ê’ÃÍ’¤¬-1’¤Ç’¤Ê’¤±’¤ì’¤Ðtrue’¡¢-1’¤Î’¾ì’¹ç’¤Ïfalse’¤ò’ÊÖ’¤·’¤Þ’¤¹’¡£indexOfSlice’¥á’¥½’¥Ã’¥É’¤Ï<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%8C%E3%83%BC%E3%82%B9%E2%80%93%E3%83%A2%E3%83%AA%E3%82%B9%E2%80%93%E3%83%97%E3%83%A9%E3%83%83%E3%83%88%E6%B3%95" target="_blank">’¥¯’¥Ì’¡¼’¥¹œôòó’¥â’¥ê’¥¹œôòó’¥×’¥é’¥Ã’¥È’Ë¡</a>’¡Ê’°Ê’²¼’¡¢KMP’Ë¡’¡Ë’¤ò’ÍÑ’¤¤’¤Æ’¼Â’Áõ’¤µ’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£
’½è’Íý’Â®’ÅÙ’¤Ï’´ð’ËÜ’Åª’¤Ë’¤Ïcontains’¥á’¥½’¥Ã’¥É’¤Î’Êý’¤¬containsSlice’¥á’¥½’¥Ã’¥É’¤è’¤ê’Â®’¤¤’¤Ç’¤¹’¡£
containsSlice’¤ÏKMP’Ë¡’¤Ç’¼Â’Áõ’¤µ’¤ì’¤Æ’¤¤’¤ë’¤Î’¤Ç’¡¢’¤½’¤Î’Ê¬’¤Î’¥ª’¡¼’¥Ð’¡¼’¥Ø’¥Ã’¥É’¤¬’¾è’¤ê’¤Þ’¤¹’¡£’¤·’¤«’¤·’¡¢’¤â’¤·’¤â’°ì’Ã×’¤Ç’¤Ï’¤Ê’¤¤’¤¬’»÷’¤Æ’¤¤’¤ë’Ê¸’»ú’Îó’¤¬’Â¿’¤¯’´Þ’¤Þ’¤ì’¤Æ’¤¤’¤ë’¤è’¤¦’¤Ê’¾ì’¹ç’¡Ê’Îã’¤¨’¤Ð’¡¢DNA’Ãæ’¤Ë’ÆÃ’Äê’¤Î’°ä’ÅÁ’»Ò’ÇÛ’Îó’¤¬’´Þ’¤Þ’¤ì’¤Æ’¤¤’¤ë’¤«’Ä´’¤Ù’¤ë’¾ì’¹ç’¡Ë’¤Ë’¤ÏKMP’Ë¡’¤Ç’¼Â’Áõ’¤µ’¤ì’¤Æ’¤¤’¤ëcontainsSlice’¥á’¥½’¥Ã’¥É’¤Î’Êý’¤¬contains’¥á’¥½’¥Ã’¥É’¤è’¤ê’¸ú’Î¨’Åª’¤Ë’½è’Íý’¤ò’¹Ô’¤¤’¤Þ’¤¹’¡£KMP’Ë¡’¤Î’¤è’¤¦’¤Ê’Ê¸’»ú’Îó’Ãµ’º÷’¥¢’¥ë’¥´’¥ê’¥º’¥à’¤Ë’¤Ä’¤¤’¤Æ’¤Ï<a href="#’¥³’¥é’¥à’Ê¸’»ú’Îó’Ãµ’º÷’¥¢’¥ë’¥´’¥ê’¥º’¥à">’¥³’¥é’¥à’¡§’Ê¸’»ú’Îó’Ãµ’º÷’¥¢’¥ë’¥´’¥ê’¥º’¥à</a>’¤ò’¤´’»²’¾È’¤¯’¤À’¤µ’¤¤’¡£
```scala
  private val unagiCopula: String = "’ËÍ’¤Ï’¥¦’¥Ê’¥®"
  
  @Test
  def testContains(): Unit = {
    assert(unagiCopula.contains("’¥¦’¥Ê’¥®"))
    assert(unagiCopula.containsSlice("’¥¦’¥Ê’¥®"))
  }
```
***
<h4>1.1.4’¡¡’Éô’Ê¬’°ì’Ã×’¡Ê’Àµ’µ¬’É½’¸½’¡Ë</h4>
’°ì’²ó’¤À’¤±’Éô’Ê¬’°ì’Ã×’¤ò’¤ß’¤¿’¤¤’¾ì’¹ç’¤Ï’¡¢Pattern’¥¯’¥é’¥¹’¤Îfind’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’Ë¡’¤ÈRegex’¥¯’¥é’¥¹’¤ÎfindFirstIn’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’Ë¡’¤ÈRegex’¥¯’¥é’¥¹’¤ÎfindFirstMatchIn’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’Ë¡’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£’Á´’¤Æ’¤Î’Éô’Ê¬’°ì’Ã×’¤ò’¸«’¤¿’¤¤’¾ì’¹ç’¤Ï’¡¢Pattern’¥¯’¥é’¥¹’¤Îfind’¥á’¥½’¥Ã’¥É’¤Ènext’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’Ë¡’¤ÈRegex’¥¯’¥é’¥¹’¤ÎfindAllIn’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’Ë¡’¤ÈRegex’¥¯’¥é’¥¹’¤ÎfindAllMatchIn’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’Ë¡’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£Regex’¥¯’¥é’¥¹’¤ÎfindFirstIn’¥á’¥½’¥Ã’¥É’¤ÈfindAllIn’¥á’¥½’¥Ã’¥É’¤Ï’¤½’¤ì’¤¾’¤ìOption[String]’¤ÈMatchIterator’¤ò’ÊÖ’¤·’¤Þ’¤¹’¡£Regex’¥¯’¥é’¥¹’¤ÎfindFirstMatchIn’¥á’¥½’¥Ã’¥É’¤äfindAllMatchIn’¥á’¥½’¥Ã’¥É’¤ÏOption[Match]’¤ÈIterator[Match]’¤ò’ÊÖ’¤·’¤Þ’¤¹’¡£Regex’¥¯’¥é’¥¹’¤ÈMatch’¥¯’¥é’¥¹’¤Î’´Ø’·¸’¤ÏJava’Í³’Íè’¤ÎPattern’¥¯’¥é’¥¹’¤Ë’ÂÐ’¤¹’¤ëMatcher’¥¯’¥é’¥¹’¤Î’´Ø’·¸’¤È’»÷’¤Æ’¤ª’¤ê’¡¢Match’¥¯’¥é’¥¹’¤Î’Â¿’¤¯’¤Î’¥á’¥½’¥Ã’¥É’¤ÏMatcher’¥¯’¥é’¥¹’¤Ë’¤â’Æ±’ÍÍ’¤Ë’Â¸’ºß’¤·’¤Þ’¤¹’¡£
```scala
  private val tautology: String = "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£"

  @Test
  def testBroadMatch1(): Unit = {
    val pattern: Pattern = Pattern.compile("’¥¦’¥Ê’¥®")
    val matcher: Matcher = pattern.matcher(tautology)

    assert(matcher.find())
  }

  @Test
  def testBroadMatch2(): Unit = {
    val regex: Regex = """’¥¦’¥Ê’¥®""".r
    val firstIn: Option[String] = regex.findFirstIn(tautology)

    assert(firstIn.nonEmpty)
  }

  @Test
  def testBroadMatch3(): Unit = {
    val regex: Regex = """’¥¦’¥Ê’¥®""".r
    val allIn: MatchIterator = regex.findAllIn(tautology)

    assert(allIn.nonEmpty)
    assert(allIn.size == 2)
  }

  @Test
  def testBroadMatch4(): Unit = {
    val regex: Regex = """’¥¦’¥Ê’¥®""".r
    val firstMatch: Option[Match] = regex.findFirstMatchIn(tautology)

    assert(firstMatch.nonEmpty)
  }

  @Test
  def testBroadMatch5(): Unit = {
    val regex: Regex = """’¥¦’¥Ê’¥®""".r
    val allMatch: Iterator[Match] = regex.findAllMatchIn(tautology)

    assert(allMatch.nonEmpty)
    assert(allMatch.size == 2)
  }
```
***
<h4>1.1.5’¡¡’Á°’Êý’°ì’Ã×’¡Ê’É½’ÁØ’Ê¸’»ú’Îó’¡Ë</h4>
’É½’ÁØ’Ê¸’»ú’Îó’¤Î’Á°’Êý’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤ÏString’¥¯’¥é’¥¹’¤ÎstartsWith’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
```scala
  @Test
  def testStartsWith(): Unit = {
    assert(tautology.startsWith("’¥¦’¥Ê’¥®"))
  }
```
***
<h4>1.1.6’¡¡’Á°’Êý’°ì’Ã×’¡Ê’Àµ’µ¬’É½’¸½’¡Ë</h4>
’¥Ñ’¥¿’¡¼’¥ó’¥Þ’¥Ã’¥Á’¤Ë’¤è’¤ë’Á°’Êý’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤Ï’¡¢Pattern’¥¯’¥é’¥¹’¤ÈMatcher’¥¯’¥é’¥¹’¤ò’ÍÑ’¤¤’¤Æ’¡¢Matcher’¥¯’¥é’¥¹’¤ÎlookingAt’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’¤³’¤È’¤¬’¤Ç’¤­’¤Þ’¤¹’¡£’Éô’Ê¬’°ì’Ã×’¤Î’Êý’Ë¡’¤ò’ÍÑ’¤¤’¤Æ’¡¢’Àµ’µ¬’É½’¸½’¤Ç’½ñ’¤¤’¤¿’¥Ñ’¥¿’¡¼’¥ó’¤Ë’ÂÐ’¤·’¤Æ’Á°’Êý’°ì’Ã×’¤ò’¼¨’¤¹’¡Ö^’¡×’¤ò’Àè’Æ¬’¤Ë’²Ã’¤¨’¤ë’Êý’Ë¡’¤â’¤¢’¤ê’¤Þ’¤¹’¡£
```scala
  @Test
  def testForwardMatch(): Unit = {
    val pattern: Pattern = Pattern.compile("’¥¦’¥Ê’¥®")
    val matcher: Matcher = pattern.matcher(tautology)

    assert(matcher.lookingAt())
  }
```
***
<h4>1.1.7’¡¡’¸å’Êý’°ì’Ã×’¡Ê’É½’ÁØ’Ê¸’»ú’Îó’¡Ë</h4>
’É½’ÁØ’Ê¸’»ú’Îó’¤Î’¸å’Êý’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤ÏString’¥¯’¥é’¥¹’¤ÎendsWith’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
```scala
  @Test
  def testEndsWith(): Unit = {
    assert(tautology.endsWith("’¥®’¤À’¡£"))
  }
```
***
<h4>1.1.8’¡¡’¸å’Êý’°ì’Ã×’¡Ê’Àµ’µ¬’É½’¸½’¡Ë</h4>
’Àµ’µ¬’É½’¸½’¤Ç’¸å’Êý’°ì’Ã×’¤ò’¸«’¤ë’¾ì’¹ç’¤Ï’¡¢’Àì’ÍÑ’¤Î’¥á’¥½’¥Ã’¥É’¤¬’¤¢’¤ê’¤Þ’¤»’¤ó’¡£
’Îã’¤¨’¤Ð’¡¢’°ì’Ã×’¤ò’¸«’¤¿’¤¤’Ê¸’»ú’Îó’¤ò’µÕ’½ç’¤Ë’¤·’¤Æ’¡¢Matcher’¥¯’¥é’¥¹’¤ÎlookingAt’¥á’¥½’¥Ã’¥É’¤Ç’°ì’Ã×’¤¬’¸«’¤ì’¤ë’¤è’¤¦’¤Ê’¥Ñ’¥¿’¡¼’¥ó’¤ò’ÍÑ’°Õ’¤·’¤Æ’¤ª’¤­’¡¢’¸å’Êý’°ì’Ã×’¤ò’Á°’Êý’°ì’Ã×’¤Î’Êý’Ë¡’¤Ç’¸«’¤ë’Êý’Ë¡’¤â’¤¢’¤ê’¤Þ’¤¹’¡£’Éô’Ê¬’°ì’Ã×’¤Î’Êý’Ë¡’¤ò’ÍÑ’¤¤’¤Æ’¡¢’Àµ’µ¬’É½’¸½’¤Ç’½ñ’¤¤’¤¿’¥Ñ’¥¿’¡¼’¥ó’¤Ë’ÂÐ’¤·’¤Æ’¸å’Êý’°ì’Ã×’¤ò’¼¨’¤¹’¡Ö$’¡×’¤ò’Ëö’Èø’¤Ë’²Ã’¤¨’¤ë’Êý’Ë¡’¤â’¤¢’¤ê’¤Þ’¤¹’¡£
```scala
  @Test
  def testBackwardMatch(): Unit = {
    val pattern: Pattern = Pattern.compile("’¡£’¤À’¥®")
    val matcher: Matcher = pattern.matcher(tautology.reverse)

    assert(matcher.lookingAt())
  }
```
***
<h3>1.2’¡¡’Ê¬’³ä</h3>
’Ê¸’»ú’Îó’¤ò’Ê¬’³ä’¤¹’¤ë’¤¿’¤á’¤Ë’¤Ï’Ê¬’³ä’°Ì’ÃÖ’¤Î’Í¿’¤¨’¤ë’É¬’Í×’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£’Ê¬’³ä’°Ì’ÃÖ’¤ò’Í¿’¤¨’¤ë’Êý’Ë¡’¤È’¤·’¤Æ’¡¢’Ê¸’»ú’Îó’Ãæ’¤Î’¶è’ÀÚ’¤ê’Ê¸’»ú’¤Î’Â¸’ºß’¤ò’Íø’ÍÑ’¤¹’¤ë’Êý’Ë¡’¡¢’¶è’ÀÚ’¤ê’Ê¸’»ú’¤Î’ÆÃ’¼ì’¤Ê’Îã’¤È’¤·’¤Æ’¹Ô’Ëö’Ê¸’»ú’¤ò’ÍÑ’¤¤’¤ë’Êý’Ë¡’¡¢’¥¤’¥ó’¥Ç’¥Ã’¥¯’¥¹’¤Ç’Ä¾’ÀÜ’»Ø’Äê’¤¹’¤ë’Êý’Ë¡’¡¢’Ê¸’»ú’Îó’Ãæ’¤ÎChar’¤ò’Á°’Êý’¤«’¤é’¸«’¤Æ’¤¢’¤ë’¾ò’·ï’¤ò’Ëþ’¤¿’¤µ’¤Ê’¤¯’¤Ê’¤Ã’¤¿’°Ì’ÃÖ’¤ò’»È’ÍÑ’¤¹’¤ë’Êý’Ë¡’¤¬’¤¢’¤ê’¤Þ’¤¹’¡£’¤½’¤ì’¤¾’¤ì’¤Ë’¤Ä’¤¤’¤Æ’²¼’µ­’¤Ç’Àâ’ÌÀ’¤·’¤Þ’¤¹’¡£
<h4>1.2.1’¡¡’¶è’ÀÚ’¤ê’Ê¸’»ú’¤Ë’¤è’¤ë’Ê¬’³ä</h4>
’¶è’ÀÚ’¤ê’Ê¸’»ú’¡Ê’¥Ç’¥ê’¥ß’¥¿’¡¢delimiter’¡Ë’¤Ç’¥È’¡¼’¥¯’¥ó’¡Êtoken’¡Ë’¤Ë’Ê¬’³ä’¡Êsplit’¡Ë’¤·’¤Þ’¤¹’¡£
’¤è’¤¯CSV’¡¢TSV’¡¢SSV’¥Õ’¥¡’¥¤’¥ë’¤ä’Åý’¸ì’²ò’ÀÏ’´ï’¤Î’½Ð’ÎÏ’·ë’²Ì’¤ò’¥Ñ’¡¼’¥¹’¤¹’¤ë’¤È’¤­’¤Ë’»È’ÍÑ’¤·’¤Þ’¤¹’¡£<a href="https://github.com/ynupc/scalastringcourseday5/blob/master/doc/mutability.md" target="_blank">Day 5</a>’¤Ç’¾Ò’²ð’¤·’¤¿StringJoiner’¤äString.join’¥á’¥½’¥Ã’¥É’¤Ç’¥È’¡¼’¥¯’¥ó’¤ò’¥Ç’¥ê’¥ß’¥¿’¤Ç’·ë’¹ç’¤¹’¤ë’¤Î’¤È’¤Á’¤ç’¤¦’¤É’µÕ’¤Î’½è’Íý’¤Ë’¤Ê’¤ê’¤Þ’¤¹’¡£
’¤³’¤Î’Ê¬’³ä’½è’Íý’¤ò’¹Ô’¤¦’¤¿’¤á’¤Î’¥¯’¥é’¥¹<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/StringTokenizer.html" target="_blank">StringTokenizer</a>’¤ÏJava 8’¤Ç’¤â’Æ°’ºî’¤·’¤Þ’¤¹’¤¬’¡¢Java 5’°Ê’¹ß’¸ß’´¹’À­’¤ò’ÊÝ’¤Ä’¤¿’¤á’¤Î’¥ì’¥¬’¥·’¡¼’¥¯’¥é’¥¹’¤È’¤Ê’¤Ã’¤Æ’¤ª’¤ê’¡¢’»È’ÍÑ’¤¬’¿ä’¾©’¤µ’¤ì’¤Æ’¤ª’¤ê’¤Þ’¤»’¤ó’¤Î’¤Ç’¤´’Ãí’°Õ’¤¯’¤À’¤µ’¤¤’¡£
’½è’Íý’Â®’ÅÙ’¤Î’ÌÌ’¤Ç’¤Ï’¡¢’Èó’¿ä’¾©’¤ÎStringTokenizer’¤ò’»È’ÍÑ’¤·’¤¿’¾ì’¹ç’¤¬’ºÇ’Â®’¤Ç’¡¢’¼¡’¤ËString’¥¯’¥é’¥¹’¤Îsplit’¥á’¥½’¥Ã’¥É’¤¬’¹â’Â®’¤Ç’¤¹’¡£Pattern’¥¯’¥é’¥¹’¤ò’ÍÑ’¤¤’¤ë’¾ì’¹ç’¤Ï’¡¢’²¿’ÅÙ’¤âsplit’¥á’¥½’¥Ã’¥É’¤ò’¸Æ’¤Ó’½Ð’¤¹’¤È’¤­’¡¢’ºÇ’½é’¤Ëcompile’¥á’¥½’¥Ã’¥É’¤Ç’¶è’ÀÚ’¤ê’Ê¸’»ú’¤Î’Àµ’µ¬’É½’¸½’¤ò’¥³’¥ó’¥Ñ’¥¤’¥ë’¤·’¤ÆPattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤·’¡¢’¤½’¤Î’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’»È’¤¤’²ó’¤¹’Êý’¤¬’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’À¸’À®’¤Î’¤¿’¤á’¤Î’¥ª’¡¼’¥Ð’¡¼’¥Ø’¥Ã’¥É’¤¬’¤Ê’¤¯’¡¢’½è’Íý’Â®’ÅÙ’¤È’¤µ’¤é’¤Ë’¥á’¥â’¥ê’¸ú’Î¨’¤Î’ÌÌ’¤Ç’¤â’¹¥’¤Þ’¤·’¤¤’¤Ç’¤¹’¡£
```scala
  @Test
  def testSplit1(): Unit = {
    val csv: String = "A,B,C,D,E,F"
    val delimiter: String = ","
    val tokens: Array[String] = csv.split(delimiter)
    assert(tokens.sameElements(Array[String]("A", "B", "C", "D", "E", "F")))
  }

  @Test
  def testSplit2(): Unit = {
    val csv: String = "A,B,C,D,E,F"
    val delimiter: String = ","
    val limit: Int = 3
    val tokens: Array[String] = csv.split(delimiter, limit)
    assert(tokens.sameElements(Array[String]("A", "B", "C,D,E,F")))

    val csv2: String = "A,B"
    val tokens2: Array[String] = csv2.split(delimiter, limit)
    assert(tokens2.sameElements(Array[String]("A", "B")))
  }

  @Test
  def testSplit3(): Unit = {
    val csv: String = "A,B,C,D,E,F"
    val delimiter: Pattern = Pattern.compile(",")
    val tokens: Array[String] = delimiter.split(csv)
    assert(tokens.sameElements(Array[String]("A", "B", "C", "D", "E", "F")))
  }

  @Test
  def testSplit4(): Unit = {
    val csv: String = "A,B,C,D,E,F"
    val delimiter: Pattern = Pattern.compile(",")
    val limit: Int = 3
    val tokens: Array[String] = delimiter.split(csv, limit)
    assert(tokens.sameElements(Array[String]("A", "B", "C,D,E,F")))

    val csv2: String = "A,B"
    val tokens2: Array[String] = delimiter.split(csv2, limit)
    assert(tokens2.sameElements(Array[String]("A", "B")))
  }

  @Test
  def testSplit5(): Unit = {
    val csv: String = "A,B,C,D,E,F"
    val delimiter: Pattern = Pattern.compile(",")
    val tokens: java.util.stream.Stream[String] = delimiter.splitAsStream(csv)
    val results: Array[String] = Array[String]("A", "B", "C", "D", "E", "F")
    var i = 0
    tokens.forEach(
      new Consumer[String]() {
        override def accept(str: String): Unit = {
          assert(str == results(i))
          i += 1
        }
      }
    )
  }
  
  @Test
  def testStringTokenizer(): Unit = {
    //StringTokenizer’¤Ï’¸ß’´¹’À­’¤ò’ÊÝ’¤Ä’¤¿’¤á’¤ËJava’¤¬’»Ä’¤·’¤Æ’¤¤’¤ëlegacy class’¤Ç’¤¹’¤Î’¤Ç’¡¢’²Ä’Ç½’¤Ê’¸Â’¤ê’»È’ÍÑ’¤Ï’Èò’¤±’¤Þ’¤·’¤ç’¤¦’¡£
    val stringTokenizer = new StringTokenizer("A,B,C,D,E,F", ",")
    val buffer: ListBuffer[String] = ListBuffer[String]()

    while (stringTokenizer.hasMoreTokens) {
      buffer += stringTokenizer.nextToken
    }

    assert(buffer == Seq[String]("A", "B", "C", "D", "E", "F"))
  }
```
<h4>1.2.2’¡¡’¹Ô’Ëö’Ê¸’»ú’¤Ë’¤è’¤ë’Ê¬’³ä</h4>
lines’¥á’¥½’¥Ã’¥É’¤älinesWithSeparators’¥á’¥½’¥Ã’¥É’¤ò’ÍÑ’¤¤’¤Æ’¹Ô’Ëö’Ê¸’»ú’¤Ç’Ê¬’³ä’¤·’¤Þ’¤¹’¡£
’¹Ô’Ëö’Ê¸’»ú’¤È’¤Ï’¡¢’²þ’¹Ô’Ê¸’»úLF’¡ÊLine Feed’¡Ë’¤ÎU+000A’¤È’²þ’¥Ú’¡¼’¥¸FF’¡ÊForm Feed’¡Ë’¤ÎU+000C’¤ò’»Ø’¤·’¤Þ’¤¹’¡£
lines’¥á’¥½’¥Ã’¥É’¤Ï’Ê¬’³ä’¸å’¤Ë’Ê¬’³ä’¤µ’¤ì’¤¿’Ê¸’»ú’Îó’¤«’¤é’¹Ô’Ëö’Ê¸’»ú’¤ò’ºï’½ü’¤·’¤Þ’¤¹’¤¬’¡¢linesWithSeparators’¥á’¥½’¥Ã’¥É’¤Ï’Ê¬’³ä’¸å’¤â’¹Ô’Ëö’Ê¸’»ú’¤¬’»Ä’¤ê’¤Þ’¤¹’¡£
```scala
  @Test
  def testSeparateLines1(): Unit = {
    val multiLine: String = "A,B\nC,D,E\fF"
    //’¹Ô’Ëö’Ê¸’»ú’¡§
    //LF(line feed, ’²þ’¹Ô, \n, 0x0A)
    //FF(form feed, ’²þ’¥Ú’¡¼’¥¸, \f, 0x0C)
    //’¤Ç’Ê¬’³ä’¤·’¡¢
    //’¹Ô’Ëö’Ê¸’»ú’¤Ï’ºï’½ü’¤¹’¤ë
    val it: Iterator[String] = multiLine.lines

    val buffer: ListBuffer[String] = ListBuffer[String]()
    while (it.hasNext) {
      buffer += it.next
    }

    assert(buffer == Seq[String]("A,B", "C,D,E", "F"))
  }

  @Test
  def testSeparateLines2(): Unit = {
    val multiLine: String = "A,B\nC,D,E\fF"
    //’¹Ô’Ëö’Ê¸’»ú’¡§
    //LF(line feed, ’²þ’¹Ô, \n, 0x0A)
    //FF(form feed, ’²þ’¥Ú’¡¼’¥¸, \f, 0x0C)
    //’¤Ç’Ê¬’³ä’¤·’¡¢
    //’¹Ô’Ëö’Ê¸’»ú’¤ò’»Ä’¤¹
    val it: Iterator[String] = multiLine.linesWithSeparators

    val buffer: ListBuffer[String] = ListBuffer[String]()
    while (it.hasNext) {
      buffer += it.next
    }

    assert(buffer == Seq[String]("A,B\n", "C,D,E\f", "F"))
  }
```
<h4>1.2.3’¡¡’Ê¬’³ä’°Ì’ÃÖ’¤ò’¥¤’¥ó’¥Ç’¥Ã’¥¯’¥¹’¤Ë’¤è’¤ë’»Ø’Äê’¤·’¤¿’Ê¬’³ä</h4>
String’¥¯’¥é’¥¹’¤ÎsplitAt’¥á’¥½’¥Ã’¥É’¤ò’ÍÑ’¤¤’¤Æ’Ê¬’³ä’°Ì’ÃÖ’¤ò’»Ø’Äê’¤·’¤Æ’Ê¬’³ä’¤·’¤Þ’¤¹’¡£
```scala
  @Test
  def testSplitAt(): Unit = {
    val csv: String = "A,B,C,D,E,F"
    val index: Int = 3
    //index’¤Î’°Ì’ÃÖ’¤Ç’Ê¬’³ä’¤¹’¤ë
    val pair: (String, String) = csv.splitAt(index)
    assert(pair._1 == "A,B")
    assert(pair._2 == ",C,D,E,F")

    val swappedPair: (String, String) = pair.swap
    assert(swappedPair._1 == ",C,D,E,F")
    assert(swappedPair._2 == "A,B")
  }
```
<h4>1.2.4’¡¡’¾ò’·ï’¤Ë’½¾’¤ï’¤Ê’¤¯’¤Ê’¤Ã’¤¿’°Ì’ÃÖ’¤Ë’¤è’¤ë’Ê¬’³ä</h4>
String’¥¯’¥é’¥¹’¤«’¤éspan’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Æ’¾ò’·ï’¤Ë’½¾’¤ï’¤Ê’¤¯’¤Ê’¤Ã’¤¿’°Ì’ÃÖ’¤Ç’Ê¬’³ä’¤·’¤Þ’¤¹’¡£
```scala
  @Test
  def testSpan(): Unit = {
    val csv: String = "A,B,C,D,E,F"
    val pair: (String, String) = csv span {
      char =>
        //’¾ò’·ï’¤Ë’½¾’¤ï’¤Ê’¤¯’¤Ê’¤Ã’¤¿’¤È’¤³’¤í’¤Ç’Ê¬’³ä’¤¹’¤ë
        char != 'C'
    }

    assert(pair._1 == "A,B,")
    assert(pair._2 == "C,D,E,F")
  }
```
***
<h3>1.3’¡¡’ÃÖ’´¹</h3>
’Ê¸’»ú’Îó’¤¬’¥Ñ’¥¿’¡¼’¥ó’¤Ë’¥Þ’¥Ã’¥Á’¤·’¤¿’¤é’¥Þ’¥Ã’¥Á’¤·’¤¿’²Õ’½ê’¤ò’Â¾’¤Î’Ê¸’»ú’Îó’¤Ë’ÃÖ’¤­’´¹’¤¨’¤Þ’¤¹’¡£’ÃÖ’¤­’´¹’¤¨’¤ë’Ê¸’»ú’Îó’¤ò’¶õ’Ê¸’»ú’Îó’¤Ë’¤¹’¤ë’¤³’¤È’¤Ç’¥Þ’¥Ã’¥Á’¤·’¤¿’²Õ’½ê’¤ò’ºï’½ü’¤¹’¤ë’¤³’¤È’¤â’²Ä’Ç½’¤Ç’¤¹’¡£

<h4>1.3.1’¡¡’É½’ÁØ’Ê¸’»ú’Îó’¤Î’°ì’Ã×’¤Ë’¤è’¤ë’ÃÖ’´¹</h4>
Char’¤Î’ÃÖ’´¹’¤ÏString’¥¯’¥é’¥¹’¤Îreplace’¥á’¥½’¥Ã’¥É’¤Ç’¹Ô’¤¤’¤Þ’¤¹’¡£
String’¤Î’ÃÖ’´¹’¤ÏJava’Í³’Íè’¤ÎString’¥¯’¥é’¥¹’¤Îreplace’¥á’¥½’¥Ã’¥É’¤Ç’¹Ô’¤¦’¤«’¡¢Scala’Í³’Íè’¤ÎreplaceAllLiterally’¥á’¥½’¥Ã’¥É’¤Ç’¹Ô’¤¤’¤Þ’¤¹’¡£
replace’¥á’¥½’¥Ã’¥É’¤âreplaceAllLiterally’¥á’¥½’¥Ã’¥É’¤â’Æâ’Éô’¤Ç’¤Ï’ºÇ’½ª’Åª’¤ËMatcher’¥¯’¥é’¥¹’¤ÎreplaceAll’¤Ë’Åê’¤²’¤Þ’¤¹’¤¬’¡¢’ÅÓ’Ãæ’²á’Äø’¤¬’°Û’¤Ê’¤ë’¤¿’¤áreplace’¥á’¥½’¥Ã’¥É’¤Î’Êý’¤¬replaceAllLiterally’¥á’¥½’¥Ã’¥É’¤è’¤ê’¤â’¹â’Â®’¤Ç’¤¹’¡£
replace’¥á’¥½’¥Ã’¥É’¤äreplaceAll’¥á’¥½’¥Ã’¥É’¤Î’°ú’¿ô’¤òreplaceAll’¥á’¥½’¥Ã’¥É’¤Ç’ÆÉ’¤ß’¹þ’¤á’¤ë’¤è’¤¦’¤Ë’½¤’Àµ’¤·’¤Þ’¤¹’¤¬’¡¢’ÃÖ’´¹’Ê¸’»ú’Îó’¤Ï’¤É’¤Á’¤é’¤âMatcher’¥¯’¥é’¥¹’¤ÎquoteReplacement’¥á’¥½’¥Ã’¥É’¤ò’ÍÑ’¤¤’¤Æ’ÃÖ’´¹’Ê¸’»ú’Îó’Ãæ’¤Î"\"’¤ä"$"’¤Î’Ä¾’Á°’¤Ë"\"’¤ò’ÁÞ’Æþ’¤·’¤Æ’¥¨’¥¹’¥±’¡¼’¥×’¥·’¡¼’¥±’¥ó’¥¹’¤Ë’¤·’¤Æ’¤¤’¤Þ’¤¹’¡£’Èï’ÃÖ’´¹’Ê¸’»ú’Îó’¤Ïreplace’¥á’¥½’¥Ã’¥É’¤Î’¾ì’¹çPattern’¥¯’¥é’¥¹’¤Îcompile’¥á’¥½’¥Ã’¥É’¤ÇPattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’À¸’À®’¤¹’¤ë’¤È’¤­’¤ËPattern.LITERAL’¥Õ’¥é’¥°’¤ò’ÅÏ’¤·’¤Æ’À¸’À®’¤·’¡¢’¤½’¤ÎPattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤«’¤ématcher’¥á’¥½’¥Ã’¥É’¤ÇMatcher’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤·’¤Þ’¤¹’¡£’¤½’¤·’¤Æ’¡¢’¤½’¤ÎMatcher’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ÎreplaceAll’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Æ’ÃÖ’´¹’¤·’¤Þ’¤¹’¡£’°ì’Êý’¤Ç’¡¢replaceAllLiterally’¥á’¥½’¥Ã’¥É’¤Ç’¤Ï’¡¢Pattern.LITERAL’¥Õ’¥é’¥°’¤ò’»È’ÍÑ’¤»’¤º’¤Ë’¡¢Pattern’¥¯’¥é’¥¹’¤Îquote’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Æ’¡¢’Àµ’µ¬’É½’¸½’¤Î’Àè’Æ¬’¤È’Ëö’Èø’¤Ë’¤½’¤ì’¤¾’¤ì"\\Q"’¤È"\\E"’¤ò’ÉÕ’¤±’²Ã’¤¨’¤Æ’¡¢’¥¨’¥¹’¥±’¡¼’¥×’¥·’¡¼’¥±’¥ó’¥¹’¤Î"\"’¤ò’Æó’½Å’¤Ë’½ñ’¤«’¤º’¤Ë’ºÑ’¤à’¤è’¤¦’¤Ê’Àµ’µ¬’É½’¸½’¤òString’¤È’¤·’¤Æ’¼è’ÆÀ’¤·’¤Þ’¤¹’¡£String’¥¯’¥é’¥¹’¤ÎreplaceAll’¥á’¥½’¥Ã’¥É’¤Ë’¤½’¤ì’¤é’¤ò’Åê’¤²’¤ë’¤³’¤È’¤ÇString’¥¯’¥é’¥¹’¤ÎreplaceAll’¥á’¥½’¥Ã’¥É’¤Î’Æâ’Éô’¤ÇMatcher’¥¯’¥é’¥¹’¤ÎreplaceAll’¥á’¥½’¥Ã’¥É’¤¬’¸Æ’¤Ó’½Ð’¤µ’¤ì’¤ë’»Å’ÁÈ’¤ß’¤Ç’¤¹’¡£
**Pattern.LITERAL’¥Õ’¥é’¥°’¤Ë’¤è’¤ê’Ä¾’ÀÜPattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤¹’¤ë’¤Î’¤«’¡¢’Àµ’µ¬’É½’¸½’¤Î’Àè’Æ¬’¤È’Ëö’Èø’¤Ë’¤½’¤ì’¤¾’¤ì"\\Q"’¤È"\\E"’¤ò’ÉÕ’¤±’²Ã’¤¨’¤ÆPattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤¹’¤ë’¤Î’¤«’¤Î’½è’Íý’¤Î’º¹’Ê¬’¤Ë’¤è’¤êreplace’¥á’¥½’¥Ã’¥É’¤Î’Êý’¤¬replaceAllLiterally’¥á’¥½’¥Ã’¥É’¤è’¤ê’¹â’Â®’¤Ç’¤¹’¡£**
’½è’Íý’Â®’ÅÙ’¤È’¤Ï’ÊÌ’¤Î’´Ñ’ÅÀ’¤È’¤·’¤Æ**’¥×’¥í’¥°’¥é’¥à’¤Î’²Ä’ÆÉ’À­’¤ò’¹â’¤á’¤ë’¤¿’¤á’¤ËreplaceAllLiterally’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’¤È’¤¤’¤¦’¹Í’¤¨’Êý’¤â’¤¢’¤ê’¤Þ’¤¹’¡£**
’¡ÊScala’¤ËreplaceAllLiterally’¥á’¥½’¥Ã’¥É’¤Î’¼Â’Áõ’¤ò’½¤’Àµ’¤·’¤Æ’¥×’¥ë’¥ê’¥¯’¥¨’¥¹’¥È’¤ò’Á÷’¤ë’¤È’¤¤’¤¤’¤Î’¤Ç’¤Ï’¤Ê’¤¤’¤«’¤È’»×’¤¤’¤Þ’¤¹’¡£’¡Ë
```scala
  @Test
  def testReplace1(): Unit = {
    //’ÃÖ’´¹’Á°’¤Î’¾õ’ÂÖ’¤Î’³Î’Ç§’ÍÑ
    assert(tautology == "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")

    //’Ê¸’»ú’¤Ë’°ì’Ã×’¤·’¤¿’Á´’¤Æ’¤Î’²Õ’½ê’¤ò’ÃÖ’´¹
    val replace1: String = tautology.replace('’¥Ê', '’¥µ')
    assert(replace1 == "’¥¦’¥µ’¥®’¤Ï’¥¦’¥µ’¥®’¤À’¡£")

    //’Ê¸’»ú’Îó’¤Ë’°ì’Ã×’¤·’¤¿’Á´’¤Æ’¤Î’²Õ’½ê’¤ò’ÃÖ’´¹
    val replace2: String = tautology.replace("’¥¦’¥Ê’¥®", "’¤«’¤á")
    assert(replace2 == "’¤«’¤á’¤Ï’¤«’¤á’¤À’¡£")

    //’Ê¸’»ú’Îó’¤Ë’°ì’Ã×’¤·’¤¿’Á´’¤Æ’¤Î’²Õ’½ê’¤ò’ÃÖ’´¹
    val replace3: String = tautology.replaceAllLiterally("’¥¦’¥Ê’¥®", "’¤«’¤á")
    assert(replace3 == "’¤«’¤á’¤Ï’¤«’¤á’¤À’¡£")
  }
```

<h4>1.3.2’¡¡’Àµ’µ¬’É½’¸½’¤Î’°ì’Ã×’¤Ë’¤è’¤ë’ÃÖ’´¹</h4>
’Àµ’µ¬’É½’¸½’¤Î’°ì’Ã×’¤Ç’¡¢’ºÇ’½é’¤Ë’°ì’Ã×’¤·’¤¿’²Õ’½ê’¤Ç’ÃÖ’´¹’¤¹’¤ë’¾ì’¹ç’¤ÏString’¥¯’¥é’¥¹’¤«Matcher’¥¯’¥é’¥¹’¤ÎreplaceFirst’¥á’¥½’¥Ã’¥É’¡¢’°ì’Ã×’¤·’¤¿’Á´’¤Æ’¤Î’²Õ’½ê’¤Ç’ÃÖ’´¹’¤¹’¤ë’¾ì’¹ç’¤ÏString’¥¯’¥é’¥¹’¤«Matcher’¥¯’¥é’¥¹’¤ÎreplaceAll’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£String’¥¯’¥é’¥¹’¤Î’¥á’¥½’¥Ã’¥É’¤Ï’Æâ’Éô’Åª’¤Ë’¤ÏMatcher’¥¯’¥é’¥¹’¤Î’¥á’¥½’¥Ã’¥É’¤ò’¸Æ’¤Ó’½Ð’¤·’¤Æ’¤¤’¤ë’¤¿’¤á’¡¢’°ì’ÅÙ’»È’ÍÑ’¤¹’¤ë’¾ì’¹ç’¤Ï’½è’Íý’Â®’ÅÙ’¤Ë’°ã’¤¤’¤Ï’¤¢’¤ê’¤Þ’¤»’¤ó’¡£’Ê£’¿ô’²ó’Æ±’¤¸’ÃÖ’´¹’½è’Íý’¤ò’¹Ô’¤¦’¾ì’¹ç’¤Ï’¡¢Pattern’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤·’¤½’¤ì’¤ò’»È’¤¤’²ó’¤·’¤ÆMatcher’¥¤’¥ó’¥¹’¥¿’¥ó’¥¹’¤ò’À¸’À®’¤¹’¤ë’¤È’½è’Íý’¤ò’¹â’Â®’²½’¤Ç’¤­’¤Þ’¤¹’¡£
```scala
  @Test
  def testReplace2(): Unit = {
    //’ÃÖ’´¹’Á°’¤Î’¾õ’ÂÖ’¤Î’³Î’Ç§’ÍÑ
    assert(tautology == "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")

    //’Àµ’µ¬’É½’¸½’¤Ë’ºÇ’½é’¤Ë’°ì’Ã×’¤·’¤¿’²Õ’½ê’¤Î’¤ß’ÃÖ’´¹
    val replaceFirst: String = tautology.replaceFirst(
      "[’¥Ê’¥Ë’¥Ì’¥Í’¥Î]",//’¥«’¥¿’¥«’¥Ê’¤Î’¥Ê’¹Ô’¤Î’£±’Ê¸’»ú’¤ò’É½’¤¹’Àµ’µ¬’É½’¸½
      "’¥µ")
    //’ºÇ’½é’¤Î’¡Ö’¥Ê’¡×’¤Ï’¡Ö’¥µ’¡×’¤Ë’ÃÖ’´¹’¤µ’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£
    assert(replaceFirst == "’¥¦’¥µ’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")

    //’Àµ’µ¬’É½’¸½’¤Ë’°ì’Ã×’¤·’¤¿’Á´’¤Æ’¤Î’²Õ’½ê’¤ò’ÃÖ’´¹
    val replaceAll: String = tautology.replaceAll(
      "[’¥Ê’¥Ë’¥Ì’¥Í’¥Î]",//’¥«’¥¿’¥«’¥Ê’¤Î’¥Ê’¹Ô’¤Î’£±’Ê¸’»ú’¤ò’É½’¤¹’Àµ’µ¬’É½’¸½
      "’¥µ")
    //’¡Ö’¥Ê’¡×’¤¬’Á´’¤Æ’¡Ö’¥µ’¡×’¤Ë’ÃÖ’´¹’¤µ’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£
    assert(replaceAll == "’¥¦’¥µ’¥®’¤Ï’¥¦’¥µ’¥®’¤À’¡£")
  }
  
  @Test
  def testReplace3(): Unit = {
    //’¥«’¥¿’¥«’¥Ê’¤Î’¥Ê’¹Ô’¤Î’£±’Ê¸’»ú’¤ò’É½’¤¹’Àµ’µ¬’É½’¸½
    val pattern: Pattern = Pattern.compile("[’¥Ê’¥Ë’¥Ì’¥Í’¥Î]")
    val matcher: Matcher = pattern.matcher(tautology)

    //’Àµ’µ¬’É½’¸½’¤Ë’ºÇ’½é’¤Ë’°ì’Ã×’¤·’¤¿’²Õ’½ê’¤Î’¤ß’ÃÖ’´¹
    val replaceFirst: String = matcher.replaceFirst("’¥µ")
    assert(replaceFirst == "’¥¦’¥µ’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")

    //’Àµ’µ¬’É½’¸½’¤Ë’°ì’Ã×’¤·’¤¿’Á´’¤Æ’¤Î’²Õ’½ê’¤ò’ÃÖ’´¹
    val replaceAll: String = matcher.replaceAll("’¥µ")
    assert(replaceAll == "’¥¦’¥µ’¥®’¤Ï’¥¦’¥µ’¥®’¤À’¡£")
  }
```
<h4>1.3.3’¡¡’ÈÏ’°Ï’»Ø’Äê’¤Ë’¤è’¤ë’ÃÖ’´¹</h4>
’°Ì’ÃÖ’¤ä’ÈÏ’°Ï’¤ò’¥¤’¥ó’¥Ç’¥Ã’¥¯’¥¹’¤Ç’»Ø’Äê’¤·’¤Æ’ÃÖ’´¹’¤ò’¤·’¤Þ’¤¹’¡£
’°ì’Ê¸’»ú’¤Î’¤ß’¤ò’ÃÖ’´¹’¤·’¤¿’¤¤’¾ì’¹ç’¤Ïupdated’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
’Ê¸’»ú’¤ò’Ê£’¿ô’´Þ’¤à’ÈÏ’°Ï’¤Ç’ÃÖ’´¹’¤·’¤¿’¤¤’¾ì’¹ç’¤Ïpatch’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤·’¤Þ’¤¹’¡£
```scala
  @Test
  def testUpdated(): Unit = {
    val index: Int = 6
    val replacement: Char = '’¥¸'
    val result: String = tautology.updated(index, replacement)

    //’¥¤’¥ó’¥Ç’¥Ã’¥¯’¥¹’¤¬6’¤Î’°Ì’ÃÖ’¤Ë’¤¢’¤ë’¡Ö’¥®’¡×’¤¬’¡Ö’¥¸’¡×’¤Ë’ÊÑ’´¹’¤µ’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£
    assert(tautology == "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")
    assert(result    == "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥¸’¤À’¡£")
  }

  @Test
  def testPatch(): Unit = {
    val index: Int = 4
    val offset: Int = 3
    val replacement: String = "’¥¤’¥Ì"
    val result: String = tautology.patch(index, replacement, offset)

    //’¥¤’¥ó’¥Ç’¥Ã’¥¯’¥¹’¤¬4’¤Î’°Ì’ÃÖ’¤Ë’¤¢’¤ë’¡Ö’¥¦’¡×’¤«’¤é’£³’Ê¸’»ú’Ê¬’¤Î’¡Ö’¥¦’¥Ê’¥®’¡×’¤¬’¡Ö’¥¤’¥Ì’¡×’¤Ë’ÊÑ’´¹’¤µ’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£
    assert(tautology == "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")
    assert(result    == "’¥¦’¥Ê’¥®’¤Ï’¥¤’¥Ì’¤À’¡£")
  }
```
<h4>1.3.4’¡¡’Ê£’¿ô’¤ÎChar’¤Î’Æ±’»þ’ÃÖ’´¹</h4>
collectFirst’¥á’¥½’¥Ã’¥É’¤äcollect’¥á’¥½’¥Ã’¥É’¤ò’»È’ÍÑ’¤¹’¤ë’¤³’¤È’¤Ç’¡¢’°ì’Ã×’¤·’¤¿’Ê¸’»ú’¤ò’ÊÌ’¤Î’Ê¸’»ú’¤Ë’ÊÑ’´¹’¤·’¤Þ’¤¹’¡£
replace’¥á’¥½’¥Ã’¥É’¤Ë’¤è’¤ë’Ê¸’»ú’¤Î’ÃÖ’´¹’¤ò’Ê£’¿ô’²ó’ÍÑ’¤¤’¤ë’¾ì’¹ç’¤Ï’¡¢replace’¥á’¥½’¥Ã’¥É’¤ò’¸Æ’¤Ó’½Ð’¤¹’½ç’½ø’¤Ë’¤è’¤ê’·ë’²Ì’¤¬’°Û’¤Ê’¤ë’²Ä’Ç½’À­’¤¬’¤¢’¤ë’ÅÀ’¤È’¡¢replace’¥á’¥½’¥Ã’¥É’¤ò’»È’¤¦’¤¿’¤Ó’¤ËString’¤¬’À¸’À®’¤µ’¤ì’¤Æ’Èó’¸ú’Î¨’¤Ç’¤¢’¤ë’ÅÀ’¤Ç’°Û’¤Ê’¤ê’¤Þ’¤¹’¡£
```scala
  @Test
  def testCollectFirst(): Unit = {
    val resultOpt: Option[Char] = tautology collectFirst {
      case '’¥®' => '’¥³'
      case '’¥¢' => '’¥Ê'
      case '’¥Ê' => '’¥ó'
      case '’¹â' => '’¤¯'
      case '’ÃÏ' => '’¤ó'
    }

    assert(tautology == "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")
    assert(resultOpt.nonEmpty)
    //’£²’Ê¸’»ú’ÌÜ’¤Î’¡Ö’¥Ê’¡×’¤Ë’ºÇ’½é’¤Ë’¥Þ’¥Ã’¥Á’¤¹’¤ë’¤Î’¤Ç’¡Ö’¥Ê’¡×’¤Î’ÊÑ’¹¹’Àè’¤Î’¡Ö’¥ó’¡×’¤¬resultOpt’¤Ë’³Ê’Ç¼’¤µ’¤ì’¤Æ’¤¤’¤Þ’¤¹’¡£
    assert(resultOpt.get == '’¥ó')
  }

  @Test
  def testCollect(): Unit = {
    val result: String = tautology collect {
      case '’¥®' => '’¥³'
      case '’¥¢' => '’¥Ê'
      case '’¥Ê' => '’¥ó'
      case '’¹â' => '’¤¯'
      case '’ÃÏ' => '’¤ó'
      case otherwise => otherwise
    }

    //’¡Ö’¥Ê’¡×’¤¬’¡Ö’¥ó’¡×’¤Ë’¡¢’¡Ö’¥®’¡×’¤¬’¡Ö’¥³’¡×’ÊÑ’¤ï’¤Ã’¤Æ’¤¤’¤Þ’¤¹’¡£
    assert(tautology == "’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£")
    assert(result    == "’¥¦’¥ó’¥³’¤Ï’¥¦’¥ó’¥³’¤À’¡£")
  }
```
***
<h3>1.4’¡¡’Ãê’½Ð</h3>
’Ê¸’»ú’Îó’¤«’¤é’¥Ñ’¥¿’¡¼’¥ó’¥Þ’¥Ã’¥Á’¤Ë’¤è’¤ê’Éô’Ê¬’Åª’¤Ê’Ê¸’»ú’Îó’¤ò’Ãê’½Ð’¤¹’¤ë’¤¿’¤á’¤Ë’¥°’¥ë’¡¼’¥×’¤¬’»È’¤ï’¤ì’¤Þ’¤¹’¡£<br>
’Àµ’µ¬’É½’¸½’Æâ’¤ò()’¤Ç’°Ï’¤à’¤È’¥°’¥ë’¡¼’¥×’¤¬’ºî’¤ì’¤Þ’¤¹’¡£’º¸’¤«’¤é’±¦’¤Ë’º¸’´Ý’³ç’¸Ì’¤ò’¿ô’¤¨’¤ë’¤³’¤È’¤Ç’¥°’¥ë’¡¼’¥×’ÈÖ’¹æ’¤¬’¿¶’¤é’¤ì’¤Þ’¤¹’¡£’Îã’¤¨’¤Ð’¡¢’¥¦((’¥Ê)(’¥®))’¤Î’¾ì’¹ç’¡¢’¼¡’¤Î’¤è’¤¦’¤Ë’ÈÖ’¹æ’ÉÕ’¤±’¤µ’¤ì’¤Þ’¤¹’¡£

’¥°’¥ë’¡¼’¥×’ÈÖ’¹æ|’Éô’Ê¬’¥·’¡¼’¥±’¥ó’¥¹|’È÷’¹Í
---|---|---
0|’¥¦((’¥Ê)(’¥®))|0’ÈÖ’¤Ë’¤Ï’°ì’Ã×’²Õ’½ê’¤Î’Á´’ÂÎ’¤¬’Æþ’¤ê’¤Þ’¤¹’¡£
1|((’¥Ê)(’¥®))|
2|(’¥Ê)|
3|(’¥®)|

```scala
  @Test
  def testExtractByPattern1(): Unit = {
    val pattern: Pattern = Pattern.compile("’¥¦((’¥Ê)(’¥®))")
    val matcher: Matcher = pattern.matcher(tautology)

    while (matcher.find) {
      val group: String = matcher.group

      assert(group == "’¥¦’¥Ê’¥®")
    }
  }

  @Test
  def testExtractByPattern2(): Unit = {
    val pattern: Pattern = Pattern.compile("’¥¦((’¥Ê)(’¥®))")
    val matcher: Matcher = pattern.matcher(tautology)

    while (matcher.find) {
      val group0: String = matcher.group(0)
      val group1: String = matcher.group(1)
      val group2: String = matcher.group(2)
      val group3: String = matcher.group(3)
      //java.lang.IndexOutOfBoundsException: No group 4
      //val group3: String = matcher.group(4)

      assert(group0 == "’¥¦’¥Ê’¥®")
      assert(group1 == "’¥Ê’¥®")
      assert(group2 == "’¥Ê")
      assert(group3 == "’¥®")
    }
  }

  @Test
  def testExtractByPattern3(): Unit = {
    val pattern: Pattern = Pattern.compile("’¥¦(?<first>(?<second>’¥Ê)(?<third>’¥®))")
    val matcher: Matcher = pattern.matcher(tautology)

    while (matcher.find) {
      val group0: String = matcher.group()
      val group1: String = matcher.group("first")
      val group2: String = matcher.group("second")
      val group3: String = matcher.group("third")

      assert(group0 == "’¥¦’¥Ê’¥®")
      assert(group1 == "’¥Ê’¥®")
      assert(group2 == "’¥Ê")
      assert(group3 == "’¥®")
    }
  }

  @Test
  def testExtractByPattern4(): Unit = {
    val pattern: Pattern = Pattern.compile("’¥¦(?<first>(?<second>’¥Ê)(?<third>’¥®))")
    val matcher: Matcher = pattern.matcher(tautology)

    var counter: Int = 0

    while (matcher.find) {
      counter += 1

      assert(matcher.groupCount() == 3)

      counter match {
        case 1 =>
          assert(matcher.start()           == 0)
          assert(matcher.end()             == 3)
          assert(tautology.substring(0, 3) == "’¥¦’¥Ê’¥®")
          assert(matcher.group()           == "’¥¦’¥Ê’¥®")
          assert(matcher.group(0)          == "’¥¦’¥Ê’¥®")

          assert(matcher.start("first")    == 1)
          assert(matcher.start(1)          == 1)
          assert(matcher.end("first")      == 3)
          assert(matcher.end(1)            == 3)
          assert(tautology.substring(1, 3) == "’¥Ê’¥®")
          assert(matcher.group("first")    == "’¥Ê’¥®")
          assert(matcher.group(1)          == "’¥Ê’¥®")

          assert(matcher.start("second")   == 1)
          assert(matcher.start(2)          == 1)
          assert(matcher.end("second")     == 2)
          assert(matcher.end(2)            == 2)
          assert(tautology.substring(1, 2) == "’¥Ê")
          assert(matcher.group("second")   == "’¥Ê")
          assert(matcher.group(2)          == "’¥Ê")

          assert(matcher.start("third")    == 2)
          assert(matcher.start(3)          == 2)
          assert(matcher.end("third")      == 3)
          assert(matcher.end(3)            == 3)
          assert(tautology.substring(2, 3) == "’¥®")
          assert(matcher.group("third")    == "’¥®")
          assert(matcher.group(3)          == "’¥®")

        case 2 =>
          assert(matcher.start()           == 4)
          assert(matcher.end()             == 7)
          assert(tautology.substring(4, 7) == "’¥¦’¥Ê’¥®")
          assert(matcher.group()           == "’¥¦’¥Ê’¥®")
          assert(matcher.group(0)          == "’¥¦’¥Ê’¥®")

          assert(matcher.start("first")    == 5)
          assert(matcher.start(1)          == 5)
          assert(matcher.end("first")      == 7)
          assert(matcher.end(1)            == 7)
          assert(tautology.substring(5, 7) == "’¥Ê’¥®")
          assert(matcher.group("first")    == "’¥Ê’¥®")
          assert(matcher.group(1)          == "’¥Ê’¥®")

          assert(matcher.start("second")   == 5)
          assert(matcher.start(2)          == 5)
          assert(matcher.end("second")     == 6)
          assert(matcher.end(2)            == 6)
          assert(tautology.substring(5, 6) == "’¥Ê")
          assert(matcher.group("second")   == "’¥Ê")
          assert(matcher.group(2)          == "’¥Ê")

          assert(matcher.start("third")    == 6)
          assert(matcher.start(3)          == 6)
          assert(matcher.end("third")      == 7)
          assert(matcher.end(3)            == 7)
          assert(tautology.substring(6, 7) == "’¥®")
          assert(matcher.group("third")    == "’¥®")
          assert(matcher.group(3)          == "’¥®")

        case otherwise =>
          assert(false)
      }
    }

    assert(counter == 2)
  }

  @Test
  def testExtractByRegex1(): Unit = {
    val regex: Regex = "’¥¦((’¥Ê)(’¥®))".r

    //’´°’Á´’°ì’Ã×
    val regex(first, second, third) = "’¥¦’¥Ê’¥®"

    //val regex(first, second, third) = tautology
    //scala.MatchError: ’¥¦’¥Ê’¥®’¤Ï’¥¦’¥Ê’¥®’¤À’¡£ (of class java.lang.String)

    assert(first  == "’¥Ê’¥®")
    assert(second == "’¥Ê")
    assert(third  == "’¥®")
  }

  @Test
  def testExtractByRegex2(): Unit = {
    val regex: Regex = "’¥¦((’¥Ê)(’¥®))".r

    "’¥¦’¥Ê’¥®" match {
      //’´°’Á´’°ì’Ã×
      case regex(first, second, third) =>
        assert(first  == "’¥Ê’¥®")
        assert(second == "’¥Ê")
        assert(third  == "’¥®")
      case otherwise =>
        assert(false)
    }
  }

  @Test
  def testExtractByRegex3(): Unit = {
    val regex: Regex = "’¥¦((’¥Ê)(’¥®))".r

    //’Éô’Ê¬’°ì’Ã×’¡Ê’Á°’Êý’¤«’¤é’²ò’ÀÏ’¤·’¤Æ’ºÇ’½é’¤Î’°ì’Ã×’¡Ë
    regex.findFirstIn(tautology) match {
      //’´°’Á´’°ì’Ã×
      case Some(regex(first, second, third)) =>
        assert(first  == "’¥Ê’¥®")
        assert(second == "’¥Ê")
        assert(third  == "’¥®")
      case None =>
        assert(false)
    }
  }

  @Test
  def testExtractByRegex4(): Unit = {
    val regex: Regex = "’¥¦((’¥Ê)(’¥®))".r

    //’´°’Á´’°ì’Ã×
    for (regex(first, second, third)
            //’Éô’Ê¬’°ì’Ã×’¡Ê’Á°’Êý’¤«’¤é’²ò’ÀÏ’¤·’¤Æ’ºÇ’½é’¤Î’°ì’Ã×’¡Ë
         <- regex.findFirstIn(tautology)) {
      assert(first  == "’¥Ê’¥®")
      assert(second == "’¥Ê")
      assert(third  == "’¥®")
    }
  }

  @Test
  def testExtractByRegex5(): Unit = {
    val regex: Regex = new scala.util.matching.Regex("’¥¦((’¥Ê)(’¥®))", "first", "second", "third")

    //’Éô’Ê¬’°ì’Ã×’¡Ê’Á°’Êý’¤«’¤é’²ò’ÀÏ’¤·’¤Æ’ºÇ’½é’¤Î’°ì’Ã×’¡Ë
    for (m <- regex.findFirstMatchIn(tautology)) {
      assert(tautology.substring(m.start, m.end) == "’¥¦’¥Ê’¥®")

      assert(m.groupCount == 3)
      assert(m.groupNames == Seq[String]("first", "second", "third"))

      assert(m.group("first")                          == "’¥Ê’¥®")
      assert(m.group(1)                                == "’¥Ê’¥®")
      assert(tautology.substring(m.start(1), m.end(1)) == "’¥Ê’¥®")

      assert(m.group("second")                         == "’¥Ê")
      assert(m.group(2)                                == "’¥Ê")
      assert(tautology.substring(m.start(2), m.end(2)) == "’¥Ê")

      assert(m.group("third")                          == "’¥®")
      assert(m.group(3)                                == "’¥®")
      assert(tautology.substring(m.start(3), m.end(3)) == "’¥®")
    }
  }

  @Test
  def testExtractByRegex6(): Unit = {
    val regex: Regex = new scala.util.matching.Regex("’¥¦(?<first>(?<second>’¥Ê)(?<third>’¥®))")

    //’Éô’Ê¬’°ì’Ã×’¡Ê’Á°’Êý’¤«’¤é’²ò’ÀÏ’¤·’¤Æ’ºÇ’½é’¤Î’°ì’Ã×’¡Ë
    for (m <- regex.findFirstMatchIn(tautology)) {
      assert(tautology.substring(m.start, m.end) == "’¥¦’¥Ê’¥®")

      assert(m.groupCount == 3)
      //assert(m.groupNames == Seq[String]("first", "second", "third"))
      //org.scalatest.junit.JUnitTestFailedError: Array() did not equal List("first", "second", "third")

      //assert(m.group("first")                          == "’¥Ê’¥®")
      //java.util.NoSuchElementException: group name first not defined
      assert(m.group(1)                                == "’¥Ê’¥®")
      assert(tautology.substring(m.start(1), m.end(1)) == "’¥Ê’¥®")

      //assert(m.group("second")                         == "’¥Ê")
      //java.util.NoSuchElementException: group name second not defined
      assert(m.group(2)                                == "’¥Ê")
      assert(tautology.substring(m.start(2), m.end(2)) == "’¥Ê")

      //assert(m.group("third")                          == "’¥®")
      //java.util.NoSuchElementException: group name third not defined
      assert(m.group(3)                                == "’¥®")
      assert(tautology.substring(m.start(3), m.end(3)) == "’¥®")
    }
  }

  @Test
  def testExtractByRegex7(): Unit = {
    val regex: Regex = "’¥¦((’¥Ê)(’¥®))".r

    //’Éô’Ê¬’°ì’Ã×’¡Ê’Á°’Êý’¤«’¤é’²ò’ÀÏ’¤·’¤Æ’°ì’Ã×’¤¹’¤ë’Á´’¤Æ’¡Ë
    val matches: Regex.MatchIterator = regex.findAllIn(tautology)

    assert(matches.size == 2)

    matches foreach {
      //’´°’Á´’°ì’Ã×
      case regex(first, second, third) =>
        assert(first  == "’¥Ê’¥®")
        assert(second == "’¥Ê")
        assert(third  == "’¥®")
      case otherwise =>
        assert(false)
    }
  }

  @Test
  def testExtractByRegex8(): Unit = {
    val regex: Regex = new scala.util.matching.Regex("’¥¦((’¥Ê)(’¥®))", "first", "second", "third")

    //’Éô’Ê¬’°ì’Ã×’¡Ê’Á°’Êý’¤«’¤é’²ò’ÀÏ’¤·’¤Æ’°ì’Ã×’¤¹’¤ë’Á´’¤Æ’¡Ë
    val matches: Iterator[Regex.Match] = regex.findAllMatchIn(tautology)

    assert(matches.size == 2)

    matches foreach {
      m =>
        assert(tautology.substring(m.start, m.end) == "’¥¦’¥Ê’¥®")

        assert(m.groupCount == 3)
        assert(m.groupNames == Seq[String]("first", "second", "third"))

        assert(m.group("first")                          == "’¥Ê’¥®")
        assert(m.group(1)                                == "’¥Ê’¥®")
        assert(tautology.substring(m.start(1), m.end(1)) == "’¥Ê’¥®")

        assert(m.group("second")                         == "’¥Ê")
        assert(m.group(2)                                == "’¥Ê")
        assert(tautology.substring(m.start(2), m.end(2)) == "’¥Ê")

        assert(m.group("third")                          == "’¥®")
        assert(m.group(3)                                == "’¥®")
        assert(tautology.substring(m.start(3), m.end(3)) == "’¥®")
    }
  }
```

***
<h3>’¥³’¥é’¥à’¡§’¼«’Á³’¸À’¸ì’¤Ï’¥Á’¥ç’¥à’¥¹’¥­’¡¼’³¬’ÁØ’¤Ç’¤Î’²¿’·¿’Ê¸’Ë¡’¡©</h3>
’¼«’Á³’¸À’¸ì’¤Ï’£±’·¿’Ê¸’Ë¡’¤È’£²’·¿’Ê¸’Ë¡’¤Î’´Ö’¤«’¤â’¡©’½ñ’¤­’ÅÓ’Ãæ
***
<h3>’¥³’¥é’¥à’¡§’Ê¸’»ú’Îó’Ãµ’º÷’¥¢’¥ë’¥´’¥ê’¥º’¥à</h3>
’¥¯’¥Ì’¡¼’¥¹œôòó’¥â’¥ê’¥¹œôòó’¥×’¥é’¥Ã’¥È’Ë¡ ’¥Ü’¥¤’¥ä’¡¼-’¥à’¡¼’¥¢’Ë¡ ’¥¨’¥¤’¥Ûœôòó’¥³’¥é’¥·’¥Ã’¥¯’Ë¡ ’¥é’¥Ó’¥ó-’¥«’¡¼’¥×’Ë¡ Bitap’Ë¡’¤Ë’¤Ä’¤¤’¤Æ’´Ê’Ã±’¤Ë’²ò’Àâ’¤¹’¤ë’¡£’½ñ’¤­’ÅÓ’Ãæ<br>
<a href="http://www-igm.univ-mlv.fr/~lecroq/string/" target="_blank">EXACT STRING MATCHING ALGORITHMS Animation in Java</a>
